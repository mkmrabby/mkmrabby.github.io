---
layout: compress
---

{% include base_path %}

<!doctype html>
<html lang="{{ site.locale | slice: 0,2 }}" class="no-js">
  <head>
    {% include head.html %}
    {% include head/custom.html %}
  </head>

  <body>

    {% include browser-upgrade.html %}
    {% include masthead.html %}

    {{ content }}

    <div class="page__footer">
      <footer>
        {% include footer/custom.html %}
        {% include footer.html %}
      </footer>
    </div>

    <!-- ============================
         FLOATING / INLINE GITHUB PROFILE VIEWS BADGE
         - Tries to place the badge below a DBLP link if present
         - Falls back to the floating badge (bottom-left) on the homepage
         - Badge is draggable in floating mode and adjustable (scale)
         - Position & scale are saved to localStorage per-browser
    ============================= -->
    {% if page.url == "/" %}
    <style>
      :root {
        --gh-badge-scale: 1;
      }

      /* Base container (works both floating and inline) */
      #gh-views-badge {
        display: inline-block;
        --badge-bg: rgba(255, 255, 255, 0.85);
        --badge-radius: 6px;
        --badge-padding: 0.2rem 0.3rem;
        transform-origin: center center;
        transform: scale(var(--gh-badge-scale));
        transition: transform 0.12s ease, box-shadow 0.12s ease;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        z-index: 9999;
      }

      /* Floating mode */
      #gh-views-badge.gh--floating {
        position: fixed;
        left: 1rem;
        bottom: 1rem;
        background: var(--badge-bg);
        padding: var(--badge-padding);
        border-radius: var(--badge-radius);
        box-shadow: 0 2px 6px rgba(0,0,0,0.15);
        backdrop-filter: blur(4px);
        animation: ghFadeIn 0.9s ease forwards;
        cursor: grab;
        touch-action: none;
      }

      #gh-views-badge.gh--floating:active { cursor: grabbing; }

      /* Inline mode (placed under DBLP) */
      #gh-views-badge.gh--inline {
        margin-top: 0.7rem;
        background: transparent;
        padding: 0;
        box-shadow: none;
        transform-origin: left top;
      }

      /* Image styling */
      #gh-views-badge img {
        max-width: 120px;
        height: auto;
        display: block;
        border-radius: 4px;
      }

      /* Small control bar */
      #gh-views-badge .gh-controls {
        display:flex;
        gap:6px;
        align-items:center;
        margin-top:6px;
      }
      #gh-views-badge .gh-btn {
        background: #0e75b6;
        color: white;
        border: none;
        padding: 0.18rem 0.28rem;
        border-radius: 4px;
        font-size: 12px;
        line-height: 1;
        cursor: pointer;
      }
      #gh-views-badge .gh-btn.ghost {
        background: rgba(0,0,0,0.06);
        color: #111;
      }

      /* Fade-in */
      @keyframes ghFadeIn {
        from { opacity: 0; transform: translateY(8px) scale(0.98); }
        to   { opacity: 1; transform: translateY(0) scale(1); }
      }

      /* Mobile adjustments */
      @media (max-width: 480px) {
        #gh-views-badge.gh--floating {
          left: 0.6rem;
          bottom: 0.6rem;
          padding: 0.12rem 0.18rem;
        }
        #gh-views-badge img {
          max-width: 90px;
        }
      }
    </style>

    <div id="gh-views-badge" aria-hidden="false" role="region" aria-label="GitHub profile views">
      <a id="gh-views-badge-link" href="https://mkmrabby.github.io" title="GitHub Profile Views" target="_blank" rel="noopener">
        <img id="gh-views-badge-img" src="https://komarev.com/ghpvc/?username=mkmrabby&label=Profile%20views&color=0e75b6&style=flat" alt="Profile Views Badge" />
      </a>

      <div class="gh-controls" aria-hidden="true">
        <button class="gh-btn" id="gh-scale-down" title="Decrease size">−</button>
        <button class="gh-btn" id="gh-scale-up" title="Increase size">+</button>
        <button class="gh-btn ghost" id="gh-reset" title="Reset position & size">Reset</button>
      </div>
    </div>

    <script>
      (function() {
        const STORAGE_KEY = 'ghBadgeState:v1';
        const badge = document.getElementById('gh-views-badge');

        // Default saved state
        const defaultState = {
          mode: 'floating', // 'floating' or 'inline'
          left: 16,
          top: null, // null means bottom-based positioning
          bottom: 16,
          scale: 1
        };

        function loadState() {
          try {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return Object.assign({}, defaultState);
            const parsed = JSON.parse(raw);
            return Object.assign({}, defaultState, parsed);
          } catch (e) {
            return Object.assign({}, defaultState);
          }
        }

        function saveState(s) {
          try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
          } catch (e) { /* ignore */ }
        }

        // Try to find a DBLP link on the page. If found, return its container element to insert after.
        function findDBLPAnchor() {
          // Look for direct links to dblp.org or pages that contain "DBLP" text
          const a = document.querySelector('a[href*="dblp.org"], a[href*="dblp"]');
          if (a) return a.closest('p,div,li,section,article') || a.parentElement;
          // fallback: find any element containing the text "DBLP" (case-insensitive)
          const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, {
            acceptNode(node) {
              if (node.textContent && /DBLP/i.test(node.textContent)) return NodeFilter.FILTER_ACCEPT;
              return NodeFilter.FILTER_SKIP;
            }
          });
          const found = walker.nextNode();
          return found || null;
        }

        function applyInlineMode(insertAfterNode, state) {
          badge.classList.remove('gh--floating');
          badge.classList.add('gh--inline');
          // Insert after the node
          try {
            if (insertAfterNode && insertAfterNode.parentNode) {
              insertAfterNode.parentNode.insertBefore(badge, insertAfterNode.nextSibling);
            }
          } catch (e) { /* ignore */ }
          // Apply scale
          document.documentElement.style.setProperty('--gh-badge-scale', state.scale);
          // Clear inline positioning props
          badge.style.left = '';
          badge.style.bottom = '';
          badge.style.top = '';
        }

        function applyFloatingMode(state) {
          badge.classList.remove('gh--inline');
          badge.classList.add('gh--floating');
          // Ensure badge is direct child of body for predictable fixed positioning
          if (badge.parentElement !== document.body) {
            document.body.appendChild(badge);
          }
          // Apply scale
          document.documentElement.style.setProperty('--gh-badge-scale', state.scale);
          // Set left/top/bottom using px values if available
          if (state.top !== null) {
            badge.style.top = (state.top) + 'px';
            badge.style.bottom = '';
          } else {
            badge.style.bottom = (state.bottom) + 'px';
            badge.style.top = '';
          }
          badge.style.left = (state.left) + 'px';
        }

        // Make the badge draggable when floating
        function makeDraggable(state) {
          let dragging = false;
          let startX = 0, startY = 0, startLeft = 0, startTop = 0;

          function onDown(e) {
            // only start drag if in floating mode
            if (!badge.classList.contains('gh--floating')) return;
            dragging = true;
            badge.style.transition = 'none';
            startX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
            startY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
            // current pos
            const rect = badge.getBoundingClientRect();
            startLeft = rect.left;
            startTop = rect.top;
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onUp);
            document.addEventListener('touchmove', onMove, {passive:false});
            document.addEventListener('touchend', onUp);
            e.preventDefault();
          }

          function onMove(e) {
            if (!dragging) return;
            const clientX = e.type.startsWith('touch') ? e.touches[0].clientX : e.clientX;
            const clientY = e.type.startsWith('touch') ? e.touches[0].clientY : e.clientY;
            const dx = clientX - startX;
            const dy = clientY - startY;
            const newLeft = Math.max(8, startLeft + dx);
            const newTop = Math.max(8, startTop + dy);
            badge.style.left = newLeft + 'px';
            badge.style.top = newTop + 'px';
            badge.style.bottom = '';
            e.preventDefault();
          }

          function onUp() {
            if (!dragging) return;
            dragging = false;
            badge.style.transition = '';
            // save final position to state
            const rect = badge.getBoundingClientRect();
            state.left = Math.round(rect.left);
            state.top = Math.round(rect.top);
            state.bottom = null;
            saveState(state);
            document.removeEventListener('mousemove', onMove);
            document.removeEventListener('mouseup', onUp);
            document.removeEventListener('touchmove', onMove);
            document.removeEventListener('touchend', onUp);
          }

          // Attach listeners to start drag from badge image or container
          badge.addEventListener('mousedown', onDown);
          badge.addEventListener('touchstart', onDown, {passive:false});
        }

        function setupControls(state) {
          const up = document.getElementById('gh-scale-up');
          const down = document.getElementById('gh-scale-down');
          const reset = document.getElementById('gh-reset');

          up.addEventListener('click', function() {
            state.scale = Math.min(2.0, +(state.scale + 0.1).toFixed(2));
            document.documentElement.style.setProperty('--gh-badge-scale', state.scale);
            saveState(state);
          });

          down.addEventListener('click', function() {
            state.scale = Math.max(0.6, +(state.scale - 0.1).toFixed(2));
            document.documentElement.style.setProperty('--gh-badge-scale', state.scale);
            saveState(state);
          });

          reset.addEventListener('click', function() {
            state.left = defaultState.left;
            state.top = defaultState.top;
            state.bottom = defaultState.bottom;
            state.scale = defaultState.scale;
            // Default mode remains floating
            state.mode = defaultState.mode;
            saveState(state);
            // Re-apply layout
            applyFloatingMode(state);
          });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
          const state = loadState();
          const dblpNode = findDBLPAnchor();

          // If DBLP found, place inline under it; otherwise floating
          if (dblpNode) {
            state.mode = 'inline';
            applyInlineMode(dblpNode, state);
          } else {
            state.mode = 'floating';
            applyFloatingMode(state);
            makeDraggable(state);
          }

          setupControls(state);

          // Allow double-click on badge to toggle between inline/floating modes
          badge.addEventListener('dblclick', function() {
            if (state.mode === 'floating') {
              // attempt to switch to inline by finding DBLP again
              const n = findDBLPAnchor();
              if (n) {
                state.mode = 'inline';
                saveState(state);
                applyInlineMode(n, state);
              } else {
                // no DBLP found — do nothing
              }
            } else {
              // switch to floating
              state.mode = 'floating';
              // set fallback coords if none
              state.left = state.left || defaultState.left;
              state.bottom = state.bottom || defaultState.bottom;
              state.top = null;
              saveState(state);
              applyFloatingMode(state);
              makeDraggable(state);
            }
          });
        });
      })();
    </script>
    {% endif %}

    {% include scripts.html %}

  </body>
</html>
